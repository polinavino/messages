\section{Appendix}

\begin{figure}[htb]
  \begin{align*}
    \emptytype
    & :~\{\emptytype \}
    & \text{the one-element set, and its one inhabitant}
    \\
    \fun{fst}
    & :~(A \times B) \to A
    & \text{first projection}
    \\
    \var{Key} \mapsto \var{Value}
    & \subsetneq \{~ k \mapsto v ~\mid~ k \in \var{Key},~v \in \var{Value}~ \}
    & \text{finite map with unique keys}
    \\
    [~\fun{f}~\var{b}~\mid~\var{b} ~\leftarrow ~\var{myList}~]
    & :~[C]
    & \text{list comprehension, given $\fun{f} : B \to C$}
    \\
    \fun{map}
    & :~(A \to B) \to [A] \to [B]
    & \text{apply $\fun{map}$ to every element in given list}
    \\
    \fun{map}
    & :~(A \to B) \to \powerset{A} \to \powerset{B}
    & \text{apply $\fun{map}$ to every element in given set}
    % \\
    % \var{map}~ (\var{k})
    % & = v
    % & \text{where }~k~\mapsto~v~\in~\var{map}
    % \\
    % \var{set} \restrictdom \var{map}
    % & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \in \var{set} \}
    % & \text{domain restriction}
    % \\
    % \var{set} \subtractdom \var{map}
    % & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ k \notin \var{set} \}
    % & \text{domain exclusion}
    \\
    % \var{MyType}^?
     & \var{MyType}~ \cup ~\emptytype
    & \text{maybe type}
    % \\
    % \var{map} \restrictrange \var{set}
    % & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \in \var{set} \}
    % & \text{range restriction}
    % \\
    % \var{map} \subtractrange \var{set}
    % & = \{ k \mapsto v \mid k \mapsto v \in \var{map}, ~ v \notin \var{set} \}
    % & \text{range exclusion}
    % \\
    % A \triangle B
    % & = (A \setminus B) \cup (B \setminus A)
    % & \text{symmetric difference}
    % \\
    % M \unionoverrideRight N
    % & = (\dom N \subtractdom M)\cup N
    % & \text{union override right}
    % \\
    % % M \unionoverrideLeft N
    % % & = M \cup (\dom M \subtractdom N)
    % % & \text{union override left}
    % \\
    % M \unionoverridePlus N
    % & = (M \triangle N)
    % \cup \{k\mapsto v_1+v_2\mid {k\mapsto v_1}\in M \land {k\mapsto v_2}\in N \}
    % & \text{union override plus} \\
    % & & \text{(for monoidal values)}\\
    % \\
    % M \unionoverrideMinus N
    % & = (M \triangle N)
    % \cup \{k\mapsto v_1-v_2\mid {k\mapsto v_1}\in M \land {k\mapsto v_2}\in N \}
    % & \text{union override minus} \\
    % & & \text{(for group values)}\\
    % \seqof{\powerset{T}}
    % \\
    % \llbracket s \rrbracket
    % & = \fun{hash}~s
    % & \text{hash of $s$} \\
    % &
    % & \text{power-multi-set of type $T$}
  \end{align*}
  \caption{Notation}
  \label{fig:notation:nonstandard}
\end{figure}
%
% \begin{figure}[htb]
%   \begin{align*}
%     \fun{toMap}~ &:& \Ix \to [\Output] \to (\Ix \mapsto \Output) \\
%     \fun{toMap}~\wcard~[] &=& [~] \\
%     \fun{toMap}~\var{ix}~(u~ ::~\var{outs}) &=& \{~\var{ix}\mapsto u~\} \cup \{~(\fun{toMap}~(\var{ix}+1)~\var{outs})~\}\\
%     \nextdef
%     \fun{mkOuts}~ &:& \Tx \to \UTxO \\
%     \fun{mkOuts}~{tx} &=& \{~(\var{tx},~\var{ix}) \mapsto o~ \mid~(\var{ix} \mapsto o)\in~\fun{toMap}~0~(\outputs~\var{tx})~\}\\
%     \nextdef
%     \fun{getORefs}~&~:& \Tx \to \Set{\OutputRef} \\
%     \fun{getORefs}~{tx} &=& \{~\outputref~i~\mid~i~\in~\inputs~\var{tx} ~\} \\
%   \end{align*}
%   \caption{Auxiliary UTxO functions}
%   \label{fig:utxo-func}
% \end{figure}



\begin{ruledfigure}{t}
  \begin{displaymath}
    \begin{array}{rll}
      \multicolumn{3}{l}{\textsc{Basic types}}\\
     \B, \N, \Z && \mbox{the type of Booleans, natural numbers, and integers}\\
      \H{} && \mbox{the type of bytestrings: } \bigcup_{n=0}^{\infty}\{0,1\}^{8n}\\
      % (\phi_1 : T_1, \ldots, \phi_n : T_n) && \mbox{a record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1, \ldots, T_n$}\\
      % \phi~\var{t} && \mbox{the value of $\phi$ for $t$, where $t$ has type $T$ and $\phi$ is a field of $T$}\\
      \powerset{T} && \mbox{the type of (finite) sets over $T$}\\
      $[T]$ && \mbox{the type of lists over $T$, with $\_[\_]$ as indexing and $|\_|$ as length}\\
      h::t && \mbox{the list with head $h$ and tail $t$}\\
%      x \mapsto f(x) && \mbox{an anonymous function}\\
%      \hash{c} && \mbox{a cryptographic collision-resistant hash of $c$}\\
      \Interval{A} && \mbox{the type of intervals over a totally-ordered set $A$}\\
      \FinSup{K}{M} && \mbox{the type of finitely supported functions from a type $K$ to a monoid $M$}\\
      \\
      \multicolumn{3}{l}{\textsc{Ledger primitives}}\\
      \Quantity = \Z && \mbox{an amount of an assets}\\
      \TokenName = [\Data] && \mbox{token name}\\
      \AssetID = \Policy \times \TokenName && \mbox{unique asset identifier}\\
      \Coin \in \AssetID && \mbox{asset ID of the primary currency }\\
      \Tick && \mbox{slot number representing chain time}\\
%      \Address && \mbox{an ``address'' in the blockchain}\\
      \Data && \mbox{a type of structured data}\\
%      \DataHash && \mbox{the hash of a value of type \Data{}}\\
      % \hashData : \Data \rightarrow \DataHash && \mbox{computes the hash of an value of type \Data}\\
%      \TxId && \mbox{the identifier of a transaction}\\
%      \txId : \eutxotx \rightarrow \TxId && \mbox{computes the identifier of a transaction}\\
%      \lookupTx : \Ledger \times \TxId \rightarrow \eutxotx{} && \mbox{retrieves the unique transaction with a given identifier}\\
      \Script && \mbox{the (opaque) type of scripts}\\
      \applyScript{\_}: \Script \rightarrow \Datum \times \Redeemer \times \vlctx \rightarrow \B && \mbox{applies a script to its arguments}\\
      \applyMPScript{\_}: \Script \rightarrow \Redeemer \times \mpsctx \rightarrow \B && \mbox{applies a script to its arguments}\\
      \checkSig : \eutxotx \to \pubkey \to \H \to \B && \mbox{checks that the given PK signed the transaction (excl. signatures)}\\
%      \scriptAddr : \Script \rightarrow \Address && \mbox{the address of a script}\\
\\
    \multicolumn{3}{l}{\textsc{Defined types}}\\
    \Ix  &=& \N\\
    \Policy  &=& \Script\\ %\Address
    \Redeemer  &=& \Data\\
    \Datum  &=& \Data\\
    \Signature &=& \pubkey \mapsto \H\\
    \\
    \Value   &=& \FinSup{\Policy}{\FinSup{\TokenName}{\Quantity}}\\
    % \\
    % \TxOut &=&(\addr: \Address, \val: \Value, \fun{datum}: \Datum)\\ %\datumHash: \DataHash)\\
    \\
    \OutputRef &= &(\txrefid: \Tx, \idx: \Ix)\\ %\TxId
    \\
    \Output &=&( \validator: \Script,\\
                & &\ \val : \Value, \\
                & &\ \datum: \Data )\\
    \\
    \Input &=&( \outputref: \sf{OutputRef},\\
                & &\ \fun{output}: \Output, \\
                & &\ \redeemer: \Redeemer)\\
    \\
    \eutxotx &=&(\inputs: \powerset{\Input},\\
               & &\ \outputs: [\Output],\\
               & &\ \fun{validityInterval}: \Interval{\Tick},\\
               & &\ \mint: \Value,\\
               & &\ \mintScsRdmrs: \Script \mapsto \Redeemer,\\
               & &\ \sigs: \Signature)\\
    \\
    \UTxO &=&\ \OutputRef \mapsto \Output \\
    \end{array}
  \end{displaymath}
  \caption{Primitives and basic types for the \EUTXOma{} model}
  \label{fig:eutxo-types}
\end{ruledfigure}
%
\begin{ruledfigure}{t}
  \begin{displaymath}
  \begin{array}{rll}
    % \s{OutputInfo}\s{ } &=&(\val: \Value,\\
    %                       & &\ \i{validatorHash}: \Address,\\
    %                       & &\ \datumHash: \DataHash)\\
    % \\
    % \s{InputInfo}\s{ } &=& (\outputref: \s{OutputRef},\\
    %                      & &\ \i{validatorHash}: \Address,\\
    %                      & &\ \i{datumHash}: \DataHash,\\
    %                      & &\ \i{redeemerHash}: \DataHash,\\
    %                      & &\ \s{value}: \Value)\\
    % \\
    %  \s{TxInfo}\s{ } &=&(\fun{inputInfo}: \List{\Input},\\
    %              & &\ \fun{outputInfo}: \List{\Output},\\
    %              & &\ \fun{validityInterval}: \Interval{\Tick},\\
    %              & &\ \mint: \Value,\\
    %              & &\ \mintRdmrs: \Policy \mapsto \Redeemer,\\
    %              & &\ \sigs: \FinSet{\pubkey})\\
    % \\
    \fun{toMap}~ &:& \Ix \to [\Output] \to (\Ix \mapsto \Output) \\
    \fun{toMap}~\wcard~\{\} &=& [~] \\
    \fun{toMap}~\var{ix}~[u;~\var{outs}] &=& \{~\var{ix}\mapsto u~\} \cup \{~(\fun{toMap}~(\var{ix}+1)~\var{outs})~\}\\
    \nextdef
    \fun{mkOuts}~ &:& \Tx \to \UTxO \\
    \fun{mkOuts}~{tx} &=& \{~(\var{tx},~\var{ix}) \mapsto o~ \mid~(\var{ix} \mapsto o)\in~\fun{toMap}~0~(\outputs~\var{tx})~\}\\
    \nextdef
    \fun{getORefs}~&~:& \Tx \to \powerset{\OutputRef} \\
    \fun{getORefs}~{tx} &=& \{~\outputref~i~\mid~i~\in~\inputs~\var{tx} ~\} \\
    \fun{getORefs}_U~{tx} &=& \{~\outputref~i~\mid~i~\in~\inputs~\var{tx},~U~(\outputref~i~\mapsto~\fun{output}~i) ~\} \\
    \nextdef
    \s{\vlctx}\s{ } &=& (\Tx, (\Tx,~\Input)) \\
    \s{\mpsctx}\s{ } &=& (\Tx, \Policy) \\
    \\
    % \mkTxInfo: \eutxotx \times \UTxO & \rightarrow &\Tx\\
    %                  & &   \mbox{\parbox[t]{55mm}{summarises a transaction}}\\
 %    \mkVlContext &:& \eutxotx \to \OutputRef \rightarrow \vlctx\\
 %                     & &   \mbox{\parbox[t]{55mm}{summarises a transaction for a validator script in the context of an input and a ledger state}}\\
 % \\
 %    \mkMpsContext &:& \eutxotx \to \Policy \rightarrow \mpsctx\\
 %                     & &   \mbox{\parbox[t]{55mm}{summarises a transaction for a minting policy script in the context of an currency and a ledger state}}\\
  \nextdef
  \fun{oneT} &:& \Policy \to \TokenName \to \Value \\
  \fun{oneT}~ p~n &\leteq& \{ ~p \mapsto \{~n~ \mapsto 1~\}~\} \\
  \end{array}
  \end{displaymath}
  \caption{Auxiliary functions for entering outputs into the UTxO set}
  \label{fig:ctx-types}
\end{ruledfigure}

\begin{ruledfigure}{t}
\begin{enumerate}
  \item
    \label{rule:has-input}
    \textbf{Transaction has at least one input}
    \begin{displaymath}
      \inputs~\var{tx}~\neq~\{\}
    \end{displaymath}

  \item
    \label{rule:slot-in-range}
    \textbf{The current slot is within the validity interval}
    \begin{displaymath}
      \var{slot} \in \fun{validityInterval}~\var{tx}
    \end{displaymath}

  \item
    \label{rule:all-outputs-are-positive}
    \textbf{All outputs have positive values}
    \begin{displaymath}
      \forall o \in \outputs~\var{tx},\ \val~\var{o} > 0
    \end{displaymath}

  \item
    \label{rule:all-inputs-refer-to-unspent-outputs}
    \textbf{All inputs refer to unspent outputs}
    \begin{displaymath}
      \forall (\var{oRef},~\var{o})~\in~\{(\outputref~\var{i},~\fun{output}~\var{i}) ~|~ i \in \inputs~\var{tx} \},
      ~\var{oRef}~ \mapsto~\var{o}~ \in ~\var{utxo}
    \end{displaymath}

  \item
    \label{rule:value-is-preserved}
    \textbf{Value is preserved}
    \begin{displaymath}
      \mint~\var{tx} + \sum_{i \in \inputs~\var{tx},~(\outputref~i)\mapsto~o~\in~\var{utxo}} \val~\var{o} = \sum_{o \in \outputs~\var{tx}} \val~\var{o}
    \end{displaymath}

  \item
    \label{rule:no-double-spending}
    \textbf{No output is double spent}
    \begin{displaymath}
      \textrm{If } i_1, i \in \inputs~\var{tx} \textrm{ and } \fun{fst}~ (\outputref~\var{i}) = \outputref~\var{i}
      \textrm{ then } \fun{fst}~i~ = i.
    \end{displaymath}

  \item
    \label{rule:all-inputs-validate}
    \textbf{All inputs validate}
    \begin{displaymath}
      \textrm{For all } i \in \inputs~\var{tx},\ \applyScript{\validator~\var{i}}(\datum~\var{i},\, \redeemer~\var{i},\, (\var{tx}, i)) = \true
    \end{displaymath}
  %
  % \item
  %   \label{rule:validator-scripts-hash}
  %   \textbf{Validator scripts match output addresses}
  %   \begin{displaymath}
  %     \textrm{For all } i \in tx.\inputs,\ \scriptAddr(i.\validator) = \var{utxo}(i).\addr
  %   \end{displaymath}
  %
  % \item
  %   \label{rule:datum-objects-hash}
  %   \textbf{Datum objects match output hashes}
  %   \begin{displaymath}
  %     \textrm{For all } i \in tx.\inputs,\ \hashData(i.\datum) = \var{utxo}(i).\datumHash
  %   \end{displaymath}
%
  \item
    \label{rule:forging}
    \textbf{Minting redeemers present}
    \begin{displaymath}
      \forall ~\var{pid}~ \in \supp(\mint~\var{tx}), ~~\exists
      (\var{pid},\wcard) ~\in~ \mintScsRdmrs~\var{tx}
    \end{displaymath}
  \medskip % items jammed together without this
  \item
    \label{rule:all-mpss-run}
    \textbf{All minting policy scripts validate}
    \begin{displaymath}
      \textrm{For all } (s, \var{rdmr}) \in \mintScsRdmrs~\var{tx},\ \applyMPScript{s}(\var{rdmr}, (tx, s)) = \true
    \end{displaymath}
  \medskip % items jammed together without this

  \item
    \label{rule:sigs-ok}
    \textbf{All signatures are correct}
    \begin{displaymath}
      \textrm{For all } (pk \mapsto s) \in \sigs~\var{tx},\ \checkSig(\var{tx}, pk, s) = \true
    \end{displaymath}

\end{enumerate}
\caption{Validity of a transaction $t$ in the \EUTXOma model}
\label{fig:validity}
\end{ruledfigure}
%

\begin{figure}
  \begin{align*}
    \Msg &\leteq ( \fun{inUTxO}: \OutputRef,\\
    & \fun{msgIx}: \Ix, \\
    & \fun{msgTo}: \Output,\\
    & \fun{msgFrom}: \Output,\\
    & \fun{msgValue}: \Value,\\
    & \fun{msgData}: \Data ) \\
    & \text{Type of messages}
    \nextdef
    \State &\leteq \powerset{\Msg} \\
    & \text{The $\MSGS$ state is a set of messages}
    \nextdef
    \Input &\leteq \Tx \\
    & \text{The $\MSGS$ input is the full transaction}
  \end{align*}
\caption{Message types}
\label{fig:msgs-types}
\end{figure}

\begin{figure}
  \begin{align*}
  \fun{toData} &: [(\SR \times \Msg)] \to \Data \\
  &\text{encodes a redeemer consisting of a set of messages as $\Data$} \\
  \nextdef
  \fun{fromData} &: \Data \to [(\SR \times \Msg)] \cup \{\emptytype \} \\
  &\text{decodes a $\Data$ redeemer as a set of messages or fails} \\
  \end{align*}
\caption{Decoding and encoding redeemers for validators of outputs sending and receiving messages}
\label{fig:msg-to}
\end{figure}

\begin{figure}
  \begin{align*}
    \fun{msgOutsOK} &: \UTxO \to \B \\
    \fun{msgOutsOK}~\var{utxo} &\leteq~\forall~(i\mapsto o), (j \mapsto p) \in \var{utxo}, ~i \neq j,
    \{~\msgsTT \mapsto \{ m \mapsto q \}\} \subseteq \val~ o \Rightarrow \\
    & (\{~\msgsTT \mapsto \{ m \mapsto \wcard \}\}  \cap \val~p = \{\} ~~\wedge~~(q = 1) ~~\\
    & \wedge~~(\fun{inUTxO}~(\fun{fromData}~m) \mapsto \wcard \notin \var{utxo}) ~~ \\
    & \wedge~~(\applyMPScript{\msgsTT}~(\emptytype,~(\fun{fst}~i,~\msgsTT))))
    \nextdef
    \msgTkn &:~\Msg~\to~\Value \\
    \msgTkn ~\var{msg} &\leteq \{ ~\msgsTT \mapsto \{~\fun{toData}~\var{msg} \mapsto 1~\}~\} \\
    & \text{Message token constructor}
    \nextdef
    \pi_{\Msg}~\var{utxo} &\leteq \begin{cases}
      \{~m~\mid~\wcard\mapsto o \in \var{utxo}, \msgTkn~m~ \subseteq \val~o \} & \text{ if } ~\fun{msgOutsOK}~\var{utxo} \\
      \emptytype & \text{ otherwise }
  \end{cases}
    \nextdef
    \SR &\leteq \{\send, \receive\} \\
    & \text{Tag specifying whether message is being sent or received}
    \nextdef
    \fun{getMsgRef} &: (\SR \times \Msg) \to (\OutputRef,~\Ix) \\
    \fun{getMsgRef} (\wcard, \var{msg}) &\leteq (\fun{inUTxO}~\var{msg},~\fun{msgIx}~\var{msg}) \\
    & \text{Returns unique message identifier}
  \end{align*}
\caption{Projections and auxiliary $\MSGS$ functions}
\label{fig:msgs-aux}
\end{figure}

\begin{figure}
  \begin{align*}
    & \msgsTT' : \Script \to \Script \\
    &\applyMPScript{\msgsTT'~\var{mv}}~(\wcard,~(\var{tx},~\var{pid}))~\leteq \\
    &~~~~~\fun{noDups}~(\fun{map}~\fun{getMsgRef}~\var{sndMsgs}~++~\fun{map}~\fun{getMsgRef}~\var{rcvMsgs}) \\
    &~~~~~\wedge \\
    &~~~~~\forall~(o,~\var{msg})~\in~\var{newOuts},~ (\var{msg},~(\var{inf}, \fun{msgFrom}~\var{msg}, \wcard))~\in~\var{sndMsgs} \\
    &~~~~~~~~~\wedge~\fun{inUTxO}~\var{msg}~=~\var{inf}~\wedge~\{~t~ \subseteq~\val~o~\mid~\dom~t~=~\{\var{pid}\}~\} = \fun{tknM}~\var{msg} \\
    &~~~~~~~~~\wedge~\validator~o~=~\var{mv}~\wedge~\val~o~\geq~\fun{msgValue}~\var{msg} \\
    &~~~~~\wedge \\
    &~~~~~\forall~(i,~\var{msg})~\in~\var{usedInputs},~(\var{msg},~(\wcard, \fun{msgTo}~\var{msg}, \wcard))~\in~\var{rcvMsgs}\\
    &~~~~~\wedge \\
    &~~~~~\Sigma_{(\var{msg},~\wcard)~\in~\var{sndMsgs}}~\fun{tknM}~\var{msg} ~~+~~
    \Sigma_{(\var{msg},~\wcard)~\in~\var{rcvMsgs}}~(-1) ~*~ (\fun{tknM}~\var{msg}) ~\\
    &~~~~~~~~~=~ \Sigma_{\var{pid} \mapsto \var{tkns}~\in~\mint~\var{tx}} \var{pid} \mapsto \var{tkns} \\
    &~~~~~\where \\
    &~~~~~~~~~\fun{tknM}~\var{msg} \leteq \{~\var{pid} ~\mapsto~ \{(\fun{toData}~\var{msg}) \mapsto 1\}~\} \\
    &~~~~~~~~~\var{sndMsgs} \leteq [~ (\var{msg},~i)~\mid~i\leftarrow~(\fun{toList}~(\inputs~\var{tx})),
    ~(\var{sr},~\var{msg})~ \leftarrow~ \fun{fromData}~(\redeemer~i),~\var{sr}=\send~] \\
    &~~~~~~~~~\var{rcvMsgs} \leteq [~ (\var{msg},~i)~\mid~i\leftarrow~(\fun{toList}~(\inputs~\var{tx})),
    ~(\var{sr},~\var{msg})~\leftarrow~\fun{fromData}~(\redeemer~i),~\var{sr}=\receive~] \\
    &~~~~~~~~~\var{newOuts}~\leteq ~\{~(o,~\var{msg})~\mid~o~\in~\outputs~\var{tx},~
    \fun{tknM}~\var{msg}~\subseteq~\val~o~\} \\
    &~~~~~~~~~\var{usedInputs} \leteq \{~ (i,~\var{msg})~\mid~
    i~ \in~ \inputs~\var{tx},~\fun{tknM}~\var{msg}~\subseteq~\val~(\fun{output}~i) ~\} \\
  \end{align*}
\caption{Minting policy constructor for message tokens}
\label{fig:msgs-codeTT}
\end{figure}

\begin{figure}
  \begin{align*}
    & \msgsTT \leteq \msgsTT'~\msgsVal
    \nextdef
    &\applyScript{\msgsVal}~(\wcard,~\wcard,~(\var{tx},~\var{i}))~\leteq \\
    &~~~~~\forall~\var{msg} \in~\{~m~\mid~(\msgsTT'~(\validator~(\fun{output}~\var{i})))~ \mapsto ~\{~m \mapsto 1 \} \} \subseteq ~\val~(\fun{output}~\var{i})~\}, \\
    &~~~~~ \{~(\msgsTT'~(\validator~(\fun{output}~\var{i})))~ \mapsto ~\{ \var{msg} \mapsto -1 \} \} ~\subseteq~\fun{mint}~\var{tx}
  \end{align*}
\caption{Minting policy and validator for UTxO containing message tokens}
\label{fig:msgs-codeV}
\end{figure}

\paragraph{Proof sketch of $\sim >$ relation for $\MSGS$. }
\label{pf:sim}

Suppose $(\emptytype, u, \var{tx}, u') \in \LEDGER$, and that $m = \pi~u \neq \emptytype$.
Suppose that $\{\} ~\neq~ \{\msgsTT \mapsto \var{tkns}\} ~\subseteq~ \fun{mint}~\var{tx}$.
Therefore, by \ref{rule:all-mpss-run},

\[\applyMPScript{\msgsTT}~(\emptytype,~(\var{tx},~\msgsTT))\]

Let $\var{sndMsgs}, \var{rcvMsgs}, \var{newOuts}, \var{usedInputs}$ be defined as
in the script $\msgsTT$
in \ref{fig:msgs-codeTT}, which, for the given transaction $\var{tx}$, is the same as
in the $\MSGS$ transition rules \ref{fig:messages-rule}. By inspection, the constraints
(4) and (7) of the $\MSGS$ transition rules \ref{fig:messages-rule} are satisfied by definition
of $\msgsTT$, as they are replicated exactly in $\msgsTT$.

The constraint (6) has a related constraint in $\msgsTT$, call it
\[ \fun{C} \leteq \forall~(i,~\var{msg})~\in~\var{usedInputs},~(\var{msg},~(\wcard, \fun{msgTo}~\var{msg}, \wcard))~\in~\var{rcvMsgs} \]

but it does not include the check (present in (6)) that for the given $(i, \var{msg})$,
$\var{msg} \in \pi~u$. Since $i$ is an input of $\var{tx}$ containing $\msgTkn~\var{msg}$,
and by rule \ref{rule:all-inputs-refer-to-unspent-outputs}, all inputs of a
transaction refer to unspent outputs, $\outputref~i \mapsto \fun{output}~i \in u$,
and it contains $\msgTkn~\var{msg}$. Therefore, $\var{msg} \in \pi~u$.

The constraint (2) has a related constraint in $\msgsTT$,
\[\fun{noDups}~(\fun{map}~\fun{getMsgRef}~\var{sndMsgs}~++~\fun{map}~\fun{getMsgRef}~\var{rcvMsgs})\]

but it does not require that, additionally,
\[ \fun{noDups}~(\fun{map}~\fun{getMsgRef}~\var{sndMsgs}~++~\fun{map}~\fun{inUTxO}~(\pi~u)) \]

that is, that the fields $\fun{inUTxO}~\var{msg}$ and $\fun{msgIx}~\var{msg}$ of a message
in $\var{sndMsgs}$ cannot both be the same as those fields of some message $\var{msgs'}$
that is already in $\pi~u$. This guaranteed by assumption (i) in Section \ref{sec:assmp}.
We can now use (2), (4), (6), and (7) in the rest of the proof.

Finally, we must demonstrate that
\[\pi~u' = (\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs})) \cup (\fun{map}~\fun{fst}~\var{sndMsgs}) \]

We must show that $\pi~u' \neq \emptytype$, i.e. $\fun{msgOutsOK}~u'$.
We start by showing that in $u'$, all message tokens are still in separate outputs
in quantity 1, with no duplication. All message tokens that are in $u$ but not in inputs or outputs
of $\var{tx}$ still satisfy this property in $u'$.
The newly minted singleton message tokens in $\mint~\var{tx}$ correspond to the messages
in $\var{sndMsgs}$, by (7). The messages in $\var{sndMsgs}$ are not
duplicates of existing messages by (2).
The messages in $\var{sndMsgs}$ must be minted as tokens
and placed in separate outputs, locked by UTxO validator $\msgsVal$, by (4).
No new message tokens besides those corresponding to $\var{sndMsgs}$ can be minted, by (7).
So, all newly minted
message tokens satisfy the required property. All message tokens included in the inputs of
$\var{tx}$ are burned, since by $\fun{msgOutsOK}~u$, the must be locked by $\msgsVal$.
So, all consumed message tokens are burned, and
all produced message tokens, as well as all message tokens that are not in outputs or
inputs of $\var{tx}$, satisfy the required property. This accounts for all message
tokens in $u'$ by the global POV \cite{structured}.

We must now show that all inputs that were spent to mint tokens existing on $u'$
are no longer in $u'$.
By (4), the $\fun{inUTxO}$ field of each message $\var{msg}$
in $\var{sndMsgs}$ must be the output reference an input of $\var{tx}$. Therefore,
by definition of $u'$ according to $\LEDGER$, $\fun{inUTxO}~\var{msg}$ must be removed from $u$
and not exist in $u'$. For all tokens already in $u$, by $\fun{msgOutsOK}~u$,
this must $\fun{inUTxO}~\var{msg}$ must not be in $u$. So, for all newly minted
tokens, as well as all existing tokens, $\fun{inUTxO}~\var{msg}$ must not be in $u$,
as required.
Finally, $\applyMPScript{\msgsTT}~(\emptytype,~(\var{tx},~\msgsTT))$
holds true by rule \ref{rule:all-mpss-run}.

Now, we must show that
\[ \pi~u' = (\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs})) \cup (\fun{map}~\fun{fst}~\var{sndMsgs}) \]

Let $\var{msg} \in \pi~u'$. So, either $\msgTkn~\var{msg}$ is in $u$ or
it is in outputs of $\var{tx}$. Note that $\msgTkn~\var{msg}$ cannot be in
inputs of $\var{tx}$ if it is in $u'$, because by $\msgsVal$ and $\fun{msgOutsOK}~u$,
all message tokens in inputs must be locked by $\msgsVal$, and therefore burned when spent.
By (4), set $\fun{map}~\fun{fst}~\var{sndMsgs}$
contains all the message tokens in outputs of $\var{tx}$ (which are in $\var{newOuts}$),
and the set $\pi~u$ contains all message tokens in $u$. Therefore,
\[ \var{msg} \in (\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs})) \cup (\fun{map}~\fun{fst}~\var{sndMsgs}) \]

To show the inclusion in the other direction, suppose
\[\var{msg} \in (\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs})) \cup (\fun{map}~\fun{fst}~\var{sndMsgs})\]

If $\var{msg} \in (\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs})) \subseteq \pi~u$,
it is still in $\pi~u'$. This is by the global POV, and because $\msgTkn~\var{msg}$ is
not in $\var{usedInputs}$, and therefore
not consumed by $\var{tx}$. If $\var{msg} \in (\fun{map}~\fun{fst}~\var{sndMsgs})$,
the message token $\msgTkn~\var{msg}$ must be in $\var{newOuts}$, and therefore exist in the outputs of $\var{tx}$.
By definition of $\LEDGER$, token $\msgTkn~\var{msg}$ must then be in $u'$. So, $\var{msg}$
is necessarily either in $(\pi~u \setminus (\fun{map}~\fun{fst}~\var{rcvMsgs}))$ or
$ (\fun{map}~\fun{fst}~\var{sndMsgs})$, and we are done.

\paragraph{Proof sketch of verified input-output pairs lemma. }
\label{pf:io-pairs}

Let $(s,~u,~\var{tx}, u') \in \LEDGER$, $\pi~u \neq \emptytype$ and let
\[\var{inp} \leteq (i, ~(\mathsf{useMyFunction}, v, d),~ r) \in \fun{inputs}~\var{tx}\]
such that
\begin{align*}
  [(\receive,~\Msg~m)] &= \fun{fromData}~r \\
  (\var{fIn},~\var{fOut}) ~&=~\fun{fromData}_{IO}~(\fun{msgData}~m) \\
  \fun{msgFrom}~m &= (\mathsf{checkMyFunction}, \wcard, \wcard)
\end{align*}

From the validity of the step $(s,~u,~\var{tx}, u')$ and the definition of $\var{inp}$,
we can conclude that
\[ \applyScript{\mathsf{useMyFunction}}~(d,~r,~(\var{tx},~\var{inp})) \]

so, by definition of the $\mathsf{useMyFunction}$ script,
\[(-1)~*~(\msgTkn~m)~\subseteq~\mint~\var{tx}\]

Now, all quantities of message tokens in outputs on the ledger are exactly 1. This is
implied by $\pi~u \neq \emptytype$, which calls $\fun{msgOutsOK}$ to check this.
By the POV rule \ref{rule:value-is-preserved},
we can conclude that one entry $p \mapsto w$ containing
one token $\msgTkn~m$ was spent by $\var{tx}$ from $u$. We know it is exactly one entry because,
again inspecting $\fun{msgOutsOK}$, message tokens are unique on a ledger for which
$\pi~u \neq \emptytype$. \newline

Again, by inspecting $\fun{msgOutsOK}$, we can
conclude that the token $\msgTkn~m$ in the value of the entry $p \mapsto w$ on
the ledger $u$ must be such that it was minted by some previous transaction $\fun{fst}~p \in \Tx$,
and the following script validated :

\[\applyMPScript{\msgsTT}~(\emptytype,~(\fun{fst}~p,~\msgsTT))\]

By inspecting $\msgsTT$, and therefore $\msgsTT'$, we see that $(w, m) \in \var{newOuts}$
by definition of $\var{newOuts}$, and the uniqueness of the message token $m$
(which is guaranteed by the $\fun{noDups}$ check). \newline

Therefore, by the constraint on $\var{newOuts}$ for transaction $\fun{fst}~p$,
some $(m, (q, g, r'))$ is contained in
$\var{sndMsgs}$, and is such that
\[[(\send,~\Msg~m)] = \fun{fromData}~r' \]
and

\[g = \fun{msgFrom}~m~=~(\mathsf{checkMyFunction}, \wcard, \wcard)\]

By assumption (ii) in Section \ref{sec:assmp}, we have

\[\applyScript{\mathsf{checkMyFunction}}~(\wcard,~r',~(\fun{fst}~p,~(q, g, r')) \]

Recall that $(\var{fIn},~\var{fOut}) ~=~\fun{fromData}_{IO}~(\fun{msgData}~m)$.
Inspencting $\mathsf{checkMyFunction}$, we get that
\[\fun{myFunction}~\var{fIn}~\var{fOut}\]

which, by definition, is true whenever $\fun{myFunctionCompute}~\var{fIn} = \var{fOut}$. \newline

Now, $\var{tx}$, the transaction consuming the message $m$, also requires that
the message minting policy validate,

\[\applyMPScript{\msgsTT}~(\emptytype,~(\var{tx},~\msgsTT))\]

By definition of $\msgsTT$, $(w, m) \in \var{usedInputs}$ for $\var{tx}$ must be such that
$(m,~(\wcard, \fun{msgTo}~m, \wcard))~\in~\var{rcvMsgs}$. Therefore,
the spending of a transaction input with output $(\wcard, \fun{msgTo}~m, \wcard)$
and redeemer $\fun{toData}~[(\receive, m)]$ must validate.
Note that such a
$(m,~(\wcard, \fun{msgTo}~m, \wcard))~\in~\var{rcvMsgs}$ is necessarily
unique because the $\fun{noDups}$ constraint prevents duplication of messages in
message-containing redeemers. Since $\fun{toData}~[(\receive,~\Msg~m)]$
is the redeemer of that unique input with such a redeemer, and we know that
the input

\[ (\wcard, (\mathsf{useMyFunction}, v, d), \fun{toData}~[(\receive,~\Msg~m)]) \]

has this redeemer in $\var{tx}$, it follows from $(m,~(\wcard, \fun{msgTo}~m, \wcard))~\in~\var{rcvMsgs}$
that
$\fun{msgTo}~m = (\mathsf{useMyFunction}, v, d)$.

%
%
% Here we note that the message tokens in any transaction's output are necessarily
% unique. This is ensured by (i) the $\fun{noDups}$ check), and (ii) and all message
% tokens that exist on the ledger must be burned when they are spent. The claim (ii)
% is guaraneed by $\msgsTT$ script check (called by $\fun{msgOutsOK}$) when it
% So, only newly minted unique message tokens can be
% in outputs of a transaction
% across all tokens being minted
% for an $\var{os}$ such that another
% the another output,
% $(\fun{inUTxO}~m) \mapsto \fun{msgFrom}~m$, with
% $\fun{msgFrom}~m = (\mathsf{checkMyFunction}, \wcard, \wcard)$
%
%
%
% By $\fun{msgOutsOK}$, again,
% conclude that
%


\paragraph{Proof of DS-free lemma. }
\label{pf:dsfree}
Let $\STRUC$ be a contract, and $\fun{C}$ --- a strict constraint of
$\STRUC$, so that $\STRUC \subsetneq \fun{C}$.
Suppose $\STRUC \subseteq \STRUC'$, such that
that $\STRUC \subseteq \STRUC' \cap \fun{C} \subseteq \STRUC'$, and
$\fun{s}~\STRUC = \fun{s}~\STRUC'$.
Suppose also that for any $(s, i)$ there exists
an $s'$ such that $(\emptytype, s, i, s') \in \STRUC$.

Now, let $(\emptytype, s, i, s') \in \STRUC'$. By assumption,
\[ (s, s') \in \fun{s}~\STRUC \]

We also know there is an $s''$ for the
given $s, i$ such that $(\emptytype, s, i, s'') \in \STRUC$.

Since $\STRUC \subseteq \STRUC'$, and all systems are deterministic, $s''$
must be unique, and $s' = s''$, so that $(\emptytype, s, i, s') \in \STRUC$.

Therefore, $\STRUC = \STRUC' = \STRUC' \cap \fun{C}$, and $\STRUC$ is not vulnerable to DS
with respect to $\fun{C}$. \newline
